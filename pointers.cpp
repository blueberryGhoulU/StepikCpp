#include "pointers.h"

/*
Очень часто для работы со строками нам нужно сначала вычислить длину строки.
Для C-style строк длина нигде явно не хранится, но её можно вычислить.
Напишите функцию, которая вычисляет длину C-style строки.
Учтите, что завершающий нулевой символ считать не нужно.
*/
unsigned strLenF(const char *str)
{
	unsigned res = 0;
	for (; *str != '\0'; ++str) {
		res += 1;
	}
	return res;
}


/*
Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк.
Функция конкатенации принимает на вход две C-style строки и дописывает вторую в конец первой так,
чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.
Не забудьте, что в результирующей строке должен быть только один нулевой символ — тот, что является маркером конца строки.
Гарантируется, что в первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины), чтобы разместить конкатенацию обеих строк, но не больше.
*/
void strCatF(char* to, const char* from)
{
	for (; *to != '\0'; ++to);
	//while (*to++ = *from++);
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

/*
Напишите функцию поиска первого вхождения шаблона в текст.
В качестве первого параметра функция принимает текст (C-style строка), в которой нужно искать шаблон.
В качестве второго параметра строку-шаблон (C-style строка), которую нужно найти.
Функция возвращает позицию
первого вхождения строки-шаблона, если он присутствует в строке (помните, что в C++ принято считать с 0), и
-1, если шаблона в тексте нет.

Учтите, что пустой шаблон (строка длины 0) можно найти в любом месте текста.
*/

/*
1. Для 0 индекса текста и 0 индекса шаблона:
1.1 Если 0 индекс текста == '/0', вернуть -1
1.2 Если 0 индекс шаблона == '/0', вернуть 0
1.3 Если 0 индекс текста == 0 индекс шаблона, сохранить 0 в результат и продолжить проверку для 1 индекса текста и 1 индекса шаблона
1.3.1. Если 0+k индекс текста != 0+k индексу шаблона, сместить указатель для текста и шаблона на 0 (?и сохранить -1 в результат). Продолжить проверку  для 1 индекса текста и 0 индекса шаблона (2)
1.4 Если 0 индекс текста != 0 индексу шаблона, продолжить проверку для 1 индекса текста и 0 индекса шаблона (2)

2. Для i индекса текста и 0 индекса шаблона:
2.1 Если i индекс текста == 0 индекс шаблона, сохранить 0 в результат и продолжить проверку для i+1 индекса текста и 1 индекса шаблона
2.1.1. Если i+k индекс текста != 0+k индексу шаблона, сместить указатель для текста и шаблона на 0 (?и сохранить -1 в результат). Продолжить проверку  для i+1 индекса текста и 0 индекса шаблона (2)
2.2 Если i индекс текста != 0 индексу шаблона, продолжить проверку для i индекса текста и 0 индекса шаблона (2)
*/
int strStrF(const char *text, const char *pattern)
{
	if (strLenF(text) == 0) { //обработка случая 1.1, когда текст пустой
		int res{ -1 };
		return res;
	}

	if (strLenF(pattern) == 0) { //обработка случая 1.2, когда шаблон пустой
		int res{ 0 };
		return res;
	}

	int res{ -1 };
	int count{ 0 };

	unsigned lenText{ strLenF(text) };
	unsigned lenPattern{ strLenF(pattern) };
	for (int i{ 0 }; i <= int(lenText) - int(lenPattern); ++i) { //проверяем до разницы длин строк, потому что дальше паттерн точно не попадет в текст целиком
		if (*text == *pattern) {
			res = i;
			while (*text == *pattern && *pattern != '\0' ) {
				text++;
				pattern++;
				count += 1;
			}
			if (*pattern == '\0') {
				return res;
			}
			text -= count;
			pattern -= count;
			count = 0;
			res = -1;
		}
		//pattern -= count;
		text++;
	}

	return res;
}