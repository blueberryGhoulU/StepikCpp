#include "pointers.h"
#include <iostream>

struct testStrStr {
	int ret_value;
	const char *text;
	const char *pattern;
};

/*
Очень часто для работы со строками нам нужно сначала вычислить длину строки.
Для C-style строк длина нигде явно не хранится, но её можно вычислить.
Напишите функцию, которая вычисляет длину C-style строки.
Учтите, что завершающий нулевой символ считать не нужно.
*/
unsigned strLenF(const char *str)
{
	unsigned res = 0;
	for (; *str != '\0'; ++str) {
		res += 1;
	}
	return res;
}


/*
Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк.
Функция конкатенации принимает на вход две C-style строки и дописывает вторую в конец первой так,
чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.
Не забудьте, что в результирующей строке должен быть только один нулевой символ — тот, что является маркером конца строки.
Гарантируется, что в первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины), чтобы разместить конкатенацию обеих строк, но не больше.
*/
void strCatF(char* to, const char* from)
{
	for (; *to != '\0'; ++to);
	//while (*to++ = *from++);
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

/*
Напишите функцию поиска первого вхождения шаблона в текст.
В качестве первого параметра функция принимает текст (C-style строка), в которой нужно искать шаблон.
В качестве второго параметра строку-шаблон (C-style строка), которую нужно найти.
Функция возвращает позицию
первого вхождения строки-шаблона, если он присутствует в строке (помните, что в C++ принято считать с 0), и
-1, если шаблона в тексте нет.

Учтите, что пустой шаблон (строка длины 0) можно найти в любом месте текста.
*/
int strStrF(const char *text, const char *pattern)
{
	int res{ -1 };
	return res;
}

void testStrStrF() {
	testStrStr tests[] = {
	{0, "", ""}, //0
	{0, "a", ""}, //1
	{0, "a", "a"}, //2
	{-1, "a", "b"}, //3
	{0, "aa", ""}, //4
	{0, "aa", "a"}, //5
	{0, "ab", "a"}, //6
	{1, "ba", "a"}, //7
	{-1, "bb", "a"}, //8
	{0, "aaa", ""}, //9
	{0, "aaa", "a"}, //10
	{1, "abc", "b"}, //11
	{2, "abc", "c"}, //12
	{-1, "abc", "d"}, //13
	{-1, "a", "aa"}, //14
	{-1, "a", "ba"}, //15
	{-1, "a", "ab"}, //16
	{-1, "a", "bb"}, //17
	{-1, "a", "aaa"}, //18
	{-1, "aa", "aaa"}, //19
	{0, "aaa", "aaa"}, //20
	{0, "aaab", "aaa"}, //21
	{1, "baaa", "aaa"}, //22
	{1, "baaaa", "aaa"}, //23
	{1, "baaab", "aaa"}, //24
	{-1, "abd", "abc"}, //25
	{2, "ababc", "abc"}, //26
	{3, "abdabc", "abc"}, //27
	{-1, "", "a"}, //28
	{2, "asasaf", "asaf"}, //29
	{2, "ababac", "abac"} //30
	};

	for (int i{ 0 }; i < sizeof(tests) / sizeof(tests[0]); ++i) {
		int ret = strStrF(tests[i].text, tests[i].pattern);
		(tests[i].ret_value == ret) ? std::cout << "Test #" << i << "OK\n" : std::cout << "Test #" << i << "FAILED\n";
	}
	std::cout << std::endl;

}
